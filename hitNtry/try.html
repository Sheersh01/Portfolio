<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Domain Warped Perlin Gradient</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255,255,255,0.1);
        }
        .control-group {
            margin-bottom: 12px;
        }
        label {
            display: inline-block;
            width: 120px;
            font-size: 13px;
            font-weight: 500;
        }
        input[type="range"] {
            width: 160px;
            margin-left: 10px;
        }
        input[type="color"] {
            margin-left: 10px;
            width: 50px;
            height: 30px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
        }
        .title {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #fff;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="controls">
        <div class="title">Domain Warped Gradient</div>
        <div class="control-group">
            <label>Scale:</label>
            <input type="range" id="scale" min="0.001" max="0.015" step="0.0005" value="0.003">
        </div>
        <div class="control-group">
            <label>Warp Strength:</label>
            <input type="range" id="warpStrength" min="0" max="8" step="0.1" value="3.5">
        </div>
        <div class="control-group">
            <label>Warp Scale:</label>
            <input type="range" id="warpScale" min="0.5" max="3" step="0.1" value="1.2">
        </div>
        <div class="control-group">
            <label>Band Frequency:</label>
            <input type="range" id="bandFreq" min="0.5" max="4" step="0.1" value="1.8">
        </div>
        <div class="control-group">
            <label>Speed:</label>
            <input type="range" id="speed" min="0" max="0.08" step="0.005" value="0.015">
        </div>
        <div class="control-group">
            <label>Color 1:</label>
            <input type="color" id="color1" value="#ff006e">
        </div>
        <div class="control-group">
            <label>Color 2:</label>
            <input type="color" id="color2" value="#3a86ff">
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2');
        
        if (!gl) {
            alert('WebGL2 not supported');
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        const vertexShaderSource = `#version 300 es
            in vec2 a_position;
            out vec2 v_texCoord;
            
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
                v_texCoord = a_position * 0.5 + 0.5;
            }
        `;

        const fragmentShaderSource = `#version 300 es
            precision highp float;
            
            in vec2 v_texCoord;
            out vec4 fragColor;
            
            uniform float u_time;
            uniform vec2 u_resolution;
            uniform float u_scale;
            uniform float u_warpStrength;
            uniform float u_warpScale;
            uniform float u_bandFreq;
            uniform vec3 u_color1;
            uniform vec3 u_color2;
            
            vec4 permute(vec4 x) { return mod(((x * 34.0) + 1.0) * x, 289.0); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            vec3 fade(vec3 t) { return t*t*t*(t*(t*6.0 - 15.0) + 10.0); }
            
            float cnoise(vec3 P) {
                vec3 Pi0 = floor(P), Pi1 = Pi0 + 1.0;
                Pi0 = mod(Pi0, 289.0); Pi1 = mod(Pi1, 289.0);
                vec3 Pf0 = fract(P), Pf1 = Pf0 - 1.0;
                vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
                vec4 iy = vec4(Pi0.yy, Pi1.yy);
                vec4 iz0 = Pi0.zzzz, iz1 = Pi1.zzzz;
                vec4 ixy = permute(permute(ix) + iy);
                vec4 ixy0 = permute(ixy + iz0);
                vec4 ixy1 = permute(ixy + iz1);
                vec4 gx0 = ixy0 / 7.0, gy0 = fract(floor(gx0) / 7.0) - 0.5;
                gx0 = fract(gx0);
                vec4 gz0 = 0.5 - abs(gx0) - abs(gy0);
                vec4 sz0 = step(gz0, vec4(0.0));
                gx0 -= sz0 * (step(0.0, gx0) - 0.5);
                gy0 -= sz0 * (step(0.0, gy0) - 0.5);
                vec4 gx1 = ixy1 / 7.0, gy1 = fract(floor(gx1) / 7.0) - 0.5;
                gx1 = fract(gx1);
                vec4 gz1 = 0.5 - abs(gx1) - abs(gy1);
                vec4 sz1 = step(gz1, vec4(0.0));
                gx1 -= sz1 * (step(0.0, gx1) - 0.5);
                gy1 -= sz1 * (step(0.0, gy1) - 0.5);
                vec3 g000 = vec3(gx0.x, gy0.x, gz0.x), g100 = vec3(gx0.y, gy0.y, gz0.y),
                     g010 = vec3(gx0.z, gy0.z, gz0.z), g110 = vec3(gx0.w, gy0.w, gz0.w),
                     g001 = vec3(gx1.x, gy1.x, gz1.x), g101 = vec3(gx1.y, gy1.y, gz1.y),
                     g011 = vec3(gx1.z, gy1.z, gz1.z), g111 = vec3(gx1.w, gy1.w, gz1.w);
                vec4 norm0 = taylorInvSqrt(vec4(dot(g000,g000), dot(g010,g010), dot(g100,g100), dot(g110,g110)));
                g000 *= norm0.x; g010 *= norm0.y; g100 *= norm0.z; g110 *= norm0.w;
                vec4 norm1 = taylorInvSqrt(vec4(dot(g001,g001), dot(g011,g011), dot(g101,g101), dot(g111,g111)));
                g001 *= norm1.x; g011 *= norm1.y; g101 *= norm1.z; g111 *= norm1.w;
                float n000 = dot(g000, Pf0), n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
                float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z)), n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
                float n001 = dot(g001, vec3(Pf0.xy, Pf1.z)), n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
                float n011 = dot(g011, vec3(Pf0.x, Pf1.yz)), n111 = dot(g111, Pf1);
                vec3 fade_xyz = fade(Pf0);
                vec4 n_z = mix(vec4(n000,n100,n010,n110), vec4(n001,n101,n011,n111), fade_xyz.z);
                vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
                float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
                return 2.2 * n_xyz;
            }
            
            // Domain warping function
            vec2 domainWarp(vec2 p, float time) {
                float warpX = cnoise(vec3(p * u_warpScale, time * 0.3));
                float warpY = cnoise(vec3(p * u_warpScale + 100.0, time * 0.3));
                
                // Second level of warping for more complexity
                vec2 warp1 = vec2(warpX, warpY) * u_warpStrength;
                vec2 warpedP = p + warp1;
                
                float warpX2 = cnoise(vec3(warpedP * u_warpScale * 0.7, time * 0.2));
                float warpY2 = cnoise(vec3(warpedP * u_warpScale * 0.7 + 200.0, time * 0.2));
                vec2 warp2 = vec2(warpX2, warpY2) * u_warpStrength * 0.5;
                
                return p + warp1 + warp2;
            }
            
            // Generate gradient bands
            float gradientBands(vec2 p, float time) {
                vec2 warpedP = domainWarp(p, time);
                
                // Create flowing bands using warped coordinates
                float angle = atan(warpedP.y, warpedP.x);
                float radius = length(warpedP);
                
                // Multiple band patterns
                float bands1 = sin(radius * u_bandFreq + time * 2.0);
                float bands2 = sin(angle * 3.0 + time * 1.5);
                float bands3 = sin((warpedP.x + warpedP.y) * u_bandFreq * 0.8 + time);
                
                // Combine band patterns
                float combined = (bands1 + bands2 * 0.6 + bands3 * 0.4) / 2.2;
                
                // Add flowing noise for organic movement
                float flow = cnoise(vec3(warpedP * 0.5, time * 0.4)) * 0.3;
                
                return combined + flow;
            }
            
            // Simple two-color interpolation
            vec3 getColor(float t) {
                t = (t + 1.0) * 0.5; // Normalize from [-1,1] to [0,1]
                t = smoothstep(0.0, 1.0, t); // Smooth the transition
                
                return mix(u_color1, u_color2, t);
            }
            
            void main() {
                vec2 uv = v_texCoord;
                vec2 pos = (uv - 0.5) * min(u_resolution.x, u_resolution.y) * u_scale;
                
                // Generate the gradient value using domain warping
                float gradientValue = gradientBands(pos, u_time);
                
                // Get the color based on gradient value
                vec3 color = getColor(gradientValue);
                
                // Add subtle brightness variation for depth
                float brightness = 0.85 + 0.3 * cnoise(vec3(pos * 1.5, u_time * 0.1));
                color *= brightness;
                
                // Slight vignette for better visual appeal
                float dist = length(uv - 0.5);
                float vignette = 1.0 - smoothstep(0.3, 0.8, dist);
                color *= 0.7 + 0.3 * vignette;
                
                fragColor = vec4(color, 1.0);
            }
        `;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program link error:', gl.getProgramInfoLog(program));
        }

        const uniforms = {
            time: gl.getUniformLocation(program, 'u_time'),
            resolution: gl.getUniformLocation(program, 'u_resolution'),
            scale: gl.getUniformLocation(program, 'u_scale'),
            warpStrength: gl.getUniformLocation(program, 'u_warpStrength'),
            warpScale: gl.getUniformLocation(program, 'u_warpScale'),
            bandFreq: gl.getUniformLocation(program, 'u_bandFreq'),
            color1: gl.getUniformLocation(program, 'u_color1'),
            color2: gl.getUniformLocation(program, 'u_color2')
        };

        const positions = new Float32Array([
            -1, -1,
             1, -1,
            -1,  1,
             1,  1
        ]);

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');
        const vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        gl.enableVertexAttribArray(positionAttributeLocation);
        gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

        // Control elements
        const controls = {
            scale: document.getElementById('scale'),
            warpStrength: document.getElementById('warpStrength'),
            warpScale: document.getElementById('warpScale'),
            bandFreq: document.getElementById('bandFreq'),
            speed: document.getElementById('speed'),
            color1: document.getElementById('color1'),
            color2: document.getElementById('color2')
        };

        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16) / 255;
            const g = parseInt(hex.slice(3, 5), 16) / 255;
            const b = parseInt(hex.slice(5, 7), 16) / 255;
            return [r, g, b];
        }

        let startTime = Date.now();
        let speed = parseFloat(controls.speed.value);

        function render() {
            const currentTime = Date.now();
            const time = (currentTime - startTime) * 0.001 * speed;
            
            gl.useProgram(program);
            gl.bindVertexArray(vao);
            
            gl.uniform1f(uniforms.time, time);
            gl.uniform2f(uniforms.resolution, canvas.width, canvas.height);
            gl.uniform1f(uniforms.scale, parseFloat(controls.scale.value));
            gl.uniform1f(uniforms.warpStrength, parseFloat(controls.warpStrength.value));
            gl.uniform1f(uniforms.warpScale, parseFloat(controls.warpScale.value));
            gl.uniform1f(uniforms.bandFreq, parseFloat(controls.bandFreq.value));
            
            const color1 = hexToRgb(controls.color1.value);
            const color2 = hexToRgb(controls.color2.value);
            
            gl.uniform3f(uniforms.color1, color1[0], color1[1], color1[2]);
            gl.uniform3f(uniforms.color2, color2[0], color2[1], color2[2]);
            
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            requestAnimationFrame(render);
        }

        controls.speed.addEventListener('input', () => {
            speed = parseFloat(controls.speed.value);
        });

        render();
    </script>
</body>
</html>